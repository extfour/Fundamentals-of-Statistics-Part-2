# Напишите функцию smart_test, которая получает на вход dataframe с двумя 
# номинативными переменными с произвольным числом градаций. Функция должна 
# проверять гипотезу о независимости этих двух переменных при помощи критерия
# хи - квадрат или точного критерия Фишера.
# 
# Если хотя бы в одной ячейке таблицы сопряженности двух переменных меньше 5
# наблюдений, функция должна рассчитывать точный критерий Фишера и возвращать
# вектор из одного элемента: получившегося p - уровня значимости.
# 
# Если наблюдений достаточно для расчета хи-квадрат (во всех ячейках больше либо
# равно 5 наблюдений), тогда функция должна применять критерий хи-квадрат и 
# возвращать вектор из трех элементов: значение хи-квадрат, число степеней
# свободы,  p-уровня значимости.
# 
# Примеры работы функции:
#   
# # Достаточно наблюдений в таблице
# > table(mtcars[,c("am", "vs")])
#   vs
# am   0  1
#   0 12  7
#   1  6  7
# > smart_test(mtcars[,c("am", "vs")])
# [1] 0.3475355 1.0000000 0.5555115
# 
# 
# # Недостаточно наблюдений в таблице
# > table(mtcars[1:20,c("am", "vs")])
#   vs
# am  0 1
#   0 8 6
#   1 2 4
# > smart_test(mtcars[1:20,c("am", "vs")])
# [1] 0.628483

smart_test <- function(df){
  table <- table(df)
  if (any(table < 5)) {
    res <- c(fisher.test(table)$p.value)
  } else {
    resp <- chisq.test(table)
    res <- c(resp$statistic, resp$parameter, resp$p.value)
  }
  return(res)
}


# Почувствуй себя биоинформатиком!  Вся наследственная информация в живых организмах хранится
# внутри молекулы ДНК. Эта молекула состоит из последовательности четырех "букв" — ﻿A, T, G и C. 
# 
# Напишите функцию most_significant, которая получает на вход dataframe с произвольным
# количеством переменных, где каждая переменная это нуклеотидная последовательность. 
# 
# Cкачайте тестовый набор данных (смотри ниже), чтобы познакомиться с их структурой, на
# которых будет тестироваться ваша функция. Рассмотрим пример, всего-лишь с несколькими
# наблюдениями, чтобы прояснить суть задачи:
#   
#   V1 V2 V3
# 1  A  A  C
# 2  G  G  A
# 3  C  C  C
# 4  T  T  A
# 5  G  T  T
# 6  T  A  G
# 
# В этом примере три последовательности  V1 , V2, V3. 
# Для каждой переменной мы можем проверить нулевую гипотезу о том, что все
# нуклеотиды (A, T, G, C) встречаются равновероятно внутри этой последовательности.
# Однако, возможно, что в некоторых последовательностях распределение частоты встречаемости
# каждого нуклеотида отличается от равномерного.
# 
# Функция должна возвращать вектор с ﻿названием переменной (или переменных), в которой был
# получен минимальный p - уровень значимости при проверке гипотезы о равномерном распределении
# нуклеотидов при помощи критерия хи - квадрат. 
# 
# > test_data <- read.csv("https://stepik.org/media/attachments/course/524/test_data.csv", 
#                         stringsAsFactors = F)
# 
# > str(test_data)
# 'data.frame':  30 obs. of  3 variables:
#   $ V1: chr  "C" "G" "C" "T" ...
# $ V2: chr  "A" "G" "C" "T" ...
# $ V3: chr  "C" "A" "C" "A" ...﻿
# 
# > most_significant(test_data)
# [1] "V3" 
# # ﻿обратите внимание,функция возвращает строку с названием
# # ﻿в этом примере ответ -﻿ одна переменная, но может быть и несколько
# 
# Подсказки:
# 1. К именам переменных легко обратиться при помощи функции colnames().
# 
# 2. Вам может пригодится функция which().    


df <- read.csv('data/test_data.csv')

f <- function(v){
  return(chisq.test(table(v))$p.value)
}
most_significant <- function(df){
  p.values <- sapply(df, f)
  min_val <- which(p.values == min(p.values))
  return(names(min_val))
}
most_significant(df)


# В лекциях я говорил, что иногда возникает необходимость перекодировать количественную 
# переменную в номинативную. Однако зачастую мы можем создавать новую номинативную переменную,
# комбинируя значения нескольких количественных переменных. Рассмотрим такой пример.
# 
# Воспользуемся встроенными в R данными Iris. Они сразу доступны для работы. Если вы не знакомы
# с историей этого набора данных, вызовите справку:
#   
#   ?iris 
# Создайте новую переменную important_cases - фактор с двумя градациями ("No" и "Yes"). 
# Переменная должна принимать значение Yes, если для данного цветка значения хотя бы трех
# количественных переменных выше среднего. В противном случае переменная important_cases
# будет принимать значение No.
# 
# Например, рассмотрим первую строчку данных iris:
#   
# Sepal.Length Sepal.Width Petal.Length Petal.Width Species
# 1            5.1         3.5          1.4         0.2  setosa
# 
# 
# В данном случае только значение  Sepal.Width 3.5 больше, чем среднее значение
# mean(Sepal.Width) = 3.057. Соответственно для первого цветка значение переменной
# important_cases будет "No".
# 
# Теперь рассмотрим 62 строчку данных
# 
# Sepal.Length Sepal.Width Petal.Length Petal.Width    Species
# 62           5.9         3            4.2            1.5 versicolor
# 
# 
# В данном случае и значение Sepal.Length 5.9 больше чем среднее по выборке, 
# mean(Sepal.Length)  = 5.84. Также значение Petal.Length и Petal.Width для этого цветка
# больше чем соответствующие средние значения: mean(Petal.Length) = 3.76,   
# mean(Petal.Width ) = 1.1.  Следовательно, для этого цветка значение переменной
# important_cases будет "Yes".
# Таким образом, если хотя бы три переменные превышают среднее значение по выборке,
# тогда  значение переменной important_cases будет "Yes".
# 
# Что должно получиться:
#   
# > str(iris$important_cases)
# Factor w/ 2 levels "No","Yes": 1 1 1 1 1 1 1 1 1 1 ...
# 
# > table(iris$important_cases)
# No Yes 
# 81  69 
# Формат ответа: в поле для ответа напишите скрипт, который создает новую 
# переменную - фактор в данных iris. Код для проверки задания считает переменную 
# important_cases из данных Iris и сравнит ее с верным ответом.
df <- iris[-5]
means <- sapply(df, mean) 

f <- function(row){
  ifelse(sum(row > means) >= 3, 1, 0)
}
res <- apply(df, MARGIN = 1, f)
iris$important_cases <- factor(res, levels = c(0, 1), labels = c('No', 'Yes'))


# Обобщим предыдущую задачу! Напишем функцию get_important_cases, которая принимает
# на вход dataframe с произвольным числом количественных переменных 
# (гарантируется хотя бы две переменные). Функция должна возвращать dataframe с новой
# переменной - фактором important_cases.
# 
# Переменная  important_cases принимает значение Yes, если для данного наблюдения
# больше половины количественных переменных имеют значения больше среднего. В противном
# случае переменная important_cases принимает значение No.
# 
# Переменная  important_cases - фактор с двумя уровнями 0 - "No", 1  - "Yes".  
# То есть даже если в каком-то из тестов все наблюдения получили значения "No", 
# фактор должен иметь две градации. 
# 
# Я написал об этой важной особенности факторов в небольшой памятке. 
# 
# Пример работы функции. 
# 
# 
# > test_data <- data.frame(V1 = c(16, 21, 18), 
#                           V2 = c(17, 7, 16), 
#                           V3 = c(25, 23, 27), 
#                           V4 = c(20, 22, 18), 
#                           V5 = c(16, 17, 19))
# 
# 
# 
# > get_important_cases(test_data)
# V1 V2 V3 V4 V5 important_cases
# 1 16 17 25 20 16              No
# 2 21  7 23 22 17              No
# 3 18 16 27 18 19             Yes


get_important_cases <- function(df){
  means <- sapply(df, mean) 
  
  f <- function(row){
    ifelse(sum(row > means) > length(row)/2, 1, 0)
  }
  res <- apply(df, MARGIN = 1, f)
  
  
  df$important_cases <- factor(res, levels = c(0, 1), labels = c('No', 'Yes'))
  
  return(df)
}

test_data <- data.frame(V1 = c(16, 21, 18), 
                        V2 = c(17, 7, 16),
                        V3 = c(25, 23, 27),
                        V4 = c(20, 22, 18),
                        V5 = c(16, 17, 19))

get_important_cases(test_data)



# Задачка на программирование.
# 
# В R мы без труда можем рассчитать среднее и медиану вектора, а вот встроенной функции
# для расчета моды — наиболее часто встречаемого значения — в R нет! А мода так бы пригодилась
# нам при анализе номинативных данных! При этом функция mode в R существует, но выполняет
# абсолютно другую задачу (если хотите узнать, какую именно, ознакомьтесь со справкой:
#                            наберите в консоли ?mode).
# 
# Напишите функцию stat_mode, которая получает на вход вектор из чисел произвольной
# длины и возвращает числовой вектор с наиболее часто встречаемым значением. 
# Если наиболее часто встречаемых значений несколько, функция должна возвращать несколько
# значений моды  в виде числового вектора. 
# 
# > v <- c(1, 2, 3, 3, 3, 4, 5)
# > stat_mode(v)
# [1] 3
# 
# > v <- c(1, 1, 1, 2, 3, 3, 3)
# > stat_mode(v)
# [1] 1 3


stat_mode <- function(vec){
  groups <- table(vec)
  modes <- as.numeric(names(groups[which(groups == max(groups))]))
  return(modes)
}
vec <- c(1, 1, 1, 2, 3, 3, 3)
stat_mode(vec)



# Доктор Пилюлькин решил вооружиться статистикой, чтобы сравнить эффективность трех лекарств!
# Давайте поможем ему и напишем функцию max_resid, которая получает на вход dataframe с двумя
# переменными: типом лекарства и результатом его применения. 
# 
# Drugs - фактор с тремя градациями: drug_1, drug_2, drug_3.     
# 
# Result - фактор с двумя градациями: positive, negative.
# 
# Функция должна находить ячейку таблицы сопряженности с максимальным  значением
# стандартизированного остатка и возвращать вектор из двух элементов: название строчки
# и столбца этой ячейки.
# 
# Для расчета стандартизированных остатков вы можете воспользоваться уже знакомой вам
# функцией chisq.test(). Изучите справку по этой функции, чтобы найти, где хранятся
# стандартизированные остатки.
# 
# Пример работы функции на одном из вариантов:
#   
# > test_data <- read.csv("https://stepik.org/media/attachments/course/524/test_drugs.csv")
# > str(test_data)
# 'data.frame':  395 obs. of  2 variables:
#   $ Drugs : Factor w/ 3 levels "drug_1","drug_2",..: 3 1 1 2 1 1 3 1 2 3 ...
# $ Result: Factor w/ 2 levels "negative","positive": 2 1 1 2 1 2 2 2 1 1 ...
# > max_resid(test_data)
# [1] "drug_1"   "positive"
# 
# # именно в этой ячейке было максимальное значение стандартизированного остатка, равное 2.07

df <- read.csv('data/test_drugs.csv', stringsAsFactors = T)

max_resid <- function(df){
  tdf <- table(df)
  stdres <- chisq.test(tdf)$stdres
  res <- which(stdres == max(stdres), arr.ind = TRUE)
  return(c(rownames(res), colnames(tdf)[res[2]]))
}


# Ну и напоследок построим гистограмму частот при помощи ggplot2!
#   
# Чтобы получить доступ к данным:
#   
# > install.packages("ggplot2") # если у вас не установлен пакет
# > library("ggplot2")
# # теперь данные diamonds доступны для работы
# > str(diamonds)
# Основной способ визуализировать распределение частот номинативной переменной - 
# гистограмма частот (барплот). Используя библиотеку ggplot2 и встроенные данные diamonds, 
# постройте график распределения частот переменной color, на котором за цвет заполнения
# столбиков отвечает переменная cut. Сохраните код графика в переменную obj. В итоге
# должен получиться вот такой график.
# 
# Для успешной проверки вашего решения не выводите переменную obj в консоль. 
# Просто сохраните в нее график.


library("ggplot2")

obj <- ggplot(diamonds, aes(x = diamonds$color, fill = diamonds$cut))+
  geom_bar( position = position_dodge())+
  xlab("color")+
  ylab("cut")
